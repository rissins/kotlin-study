## 클래스 계층 정의

### 코틀린 인터페이스

- 추상메서드, 구현이 있는 메서드 정의가 가능
- 필드 정의는 불가능
- 자바에서는 `extends`와 `implements` 키워드를 사용하지만, 코틀린에서는 클래스 이름 뒤에 ‘콜론(:)’ 사용
    - 자바와 마찬가지로 인터페이스는 개수 제한없이 구현 가능
    - 클래스는 하나만 확장 가능
- 자바 `@Override` 와 비슷한 `override` 변경자 사용
    - 상위 클래스, 인터페이스 메서드 재정의 표시
    - 자바와 달리 `override` 변경자를 꼭 사용
    - 실수로 재정의하는 경우를 방지, `override`없이 시그니처가 같은 메서드 재정의 시 컴파일 오류발생

### open, final, abstract 변경자 → 기본적으로 final

- 자바는 final로 명시적으로 상속 금지
- 취약한 기반 클래스
    - 하위 클래스가 기반 클래스가 변경되어 영향받는 문제
    - 기반 클래스를 작성한 사람의 의도와 다른 방식으로 메서드를 오버라이드 할 위험이 존재
- Effective Java → 상속을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 상속을 금지하라
    - 특별히 하위 클래스에서 오버라이드를 하게 의도된 클래스나 메서드가 아니면 final 정의
- 코틀린은 기본적으로 final이기 때문에 **상속을 허용할려면 open** 사용
- final이 기본이기때문에
    - 다양한 경우에 스마트 캐스트가 가능하다.
    - 클래스의 프로퍼티 경우 val 이면서 커스텀 접근자가 없는 경우에만 스마트 캐스트사용 가능
    - 프로퍼티는 기본적으로 final 이기때문에 대부분의 프로퍼티를 스마트 캐스트에 활용 가능
- **abstract** 클래스 선언
    - **인스턴스화 불가**
    - **기본이 open**
- 인터페이스 멤버는 final, open, abstract 키워드 사용 x, 항상 open
